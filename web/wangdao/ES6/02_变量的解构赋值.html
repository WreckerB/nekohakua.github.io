<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 01 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring） -->
    <!-- <script>
        // 以前赋值：
        let a = 1
        let b = 2
        let c = 3
        // ES6是这样：
        let [d, e, f] = [1, 2, 3]
        console.log('d-e-f', d, e, f) //1 2 3

        let [head, ...tail] = [1, 2, 3, 4]
        console.log('head', head) //1
        console.log('tail', tail) //[2, 3, 4]

        let [x, y, ...z] = ['a']
        console.log('x', x) // "a"
        console.log('y', y) // undefined
        console.log('z', z) // []

        // 如果解构不成功，变量的值就等于undefined。
        let [foo1] = []
        let [bar, foo2] = [1]
        console.log('foo1', foo1) // undefined
        console.log('bar', bar) //1
        console.log('foo2', foo2) // undefined

        // 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。
        let [x1, y1] = [1, 2, 3]
        x1 // 1
        y1 // 2
        let [a1, [b1], d1] = [1, [2, 3], 4]
        a1 // 1
        b1 // 2
        d1 // 4

        // 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。
        // let [f1] = 1 // 报错
        // let [f2] = false // 报错
    </script> -->

    <!-- 02 默认值 -->
    <!-- <script>
        // 解构赋值允许指定默认值。只有当一个数组成员严格等于undefined，默认值才会生效。
        let [foo = true] = []
        console.log('foo', foo) //true
        let [x, y = 'y'] = ['x', undefined]
        console.log('x-y', x, y) //x y
    </script> -->

    <!-- 03 对象解构 -->
    <!-- <script>
        // 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
        let { foo, bar } = { bar: 'bar', foo: 'foo'}
        console.log('foo:', foo, 'bar:', bar) //foo bar

        // 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。
        // 例一:将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多
        // let { log, sin, cos } = Math

        // 例二:将console.log赋值到log变量。
        const { log } = console;
        log('hello') // hello

        // 如果变量名与属性名不一致，必须写成下面这样。
        let { foo: baz } = { foo: 'aaa', bar: 'bbb'}
        // foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。
        console.log('baz', baz) //aaa
        let obj = { first: 'hello', last: 'world'}
        let { first: f, last: l } = obj
        console.log('f-l', f, l) //hello world

        // 对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。
        // 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。
        let { foo1: foo1, bar1: bar1 } = { foo1: 'aaa', bar1: 'bbb'}

        // 嵌套赋值的例子
        let obj1 = {}
        let arr = []
        // 上面不加;下面的()前要加！。因为避免浏览器理解为{}代码块，所以加上()
        !({ foo: obj1.prop, bar: arr[0] } = { foo: 123, bar: true })
        console.log('obj1', obj1) // {prop:123}
        console.log('arr', arr) // [true]
    </script> -->

    <!-- 04 字符串的解构赋值-->
    <script>

    </script>



</body>
</html>