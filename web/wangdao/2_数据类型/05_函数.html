<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 1 函数的声明-->
    <!-- <script>
        // 【1】
        function name(str) {
            console.log(str)
        }

        // 【2】
        // 可以采用变量赋值的声明写法
        // 这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式
        var print = function(str) {
            console.log(str)
        }

        // 采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。
        var iGetprint = function getprint() {
            return console.log(typeof getprint)
        };
        iGetprint()
        // 需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。

        // 【3】
        // 第三种声明函数的方式是Function构造函数。
        var add = new Function(
            'x',
            'y',
            'return x + y'
        )
        console.log(add(1,2))
        

        // 等同于
        function add(x, y) {
            return x + y
        }
        // 如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。
    </script> -->

    <!-- 2 函数和值（数值、字符串、布尔值等等）地位相同 -->
    <!-- <script>
        function add(x, y) {
            return x + y
        }

        // 将函数赋值给一个变量
        var operation = add

        // 将函数作为参数和返回值
        function f(op) {
            return op
        }

        console.log(f(add)(1, 2)) //3
    </script> -->

    <!-- 3 函数名提升-->
    <!-- <script>
        // JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。
        fn() //im fn
        function fn() {
            console.log("im fn")
        }

        // 但是，如果采用赋值语句定义函数，JavaScript 就会报错。
        // fn1()
        // var fn1 = function fn1() {
        //     console.log('im fn1')
        // }
        // 相当于
        // var fn1
        // fn1()
        // fn1 = function fn1() {
        //     console.log('im fn1')
        // }

        // 采用function命令和var赋值语句声明同一个函数，由于存在函数提升，最后会采用var赋值语句的定义
        var f = function () {
            console.log(1)
        }
        function f() {
            console.log(2)
        }
        f() //1

        function f2() {
            console.log(2)
        }
        var f2 = function () {
            console.log(1)
        }
        f2() //1
    </script> -->

    <!-- 4 函数的方法-->
    <!-- <script>
        function text(a, b) {
            // @
            let aa = 3
        }
        console.log(text.name)
        console.log(text.length)
        console.log(text.toString())

        // 变相实现多行字符串
        // split() 方法:把一个字符串分割成字符串数组
        var str = '1 2 3 4 5'
        var split = str.split(' ') //遇到‘ ’就分割
        console.log(split) // ['1', '2', '3', '4', '5']
        // slice()方法：通过索引位置获取新的数组，该方法不会修改原数组，只是返回一个新的子数组。
        // 用法：arrayObj.slice(start,end)
        // arrayObj - 原始数组;
        // start - 必填；设定新数组的起始位置；如果是负数，则表示从数组尾部开始算起（-1指最后一个元素，-2 指倒数第二个元素，以此类推）。
        // end - 可选；设定新数组的结束位置；如果不填写该参数，默认到数组结尾；如果是负数，则表示从数组尾部开始算起（-1 指最后一个元素，-2指倒数第二个元素，以此类推）。
        console.log(split.slice(0, -1)) //['1', '2', '3', '4']
        // join() 方法:把数组中的所有元素转换为一个字符串
        console.log(split.slice(0, -1).join('\n'))
        // 1
        // 2
        // 3
        // 4
        var multiline = function (fn) {
            var arr = fn.toString().split('\n')
            return arr.slice(1, arr.length - 1).join('\n')
        }
        function f() {/*
        这是一个
        多行注释
        */}
        console.log(multiline(f))
        // 这是一个
        // 多行注释
    </script> -->

    <!-- 5 函数内部的变量提升 -->
    <!-- <script>
        // 与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。
        function foo(x) {
            if (x > 100) {
                var tmp = x - 100
            }
        }

        // 等同于
        function foo(x) {
        var tmp
            if (x > 100) {
                tmp = x - 100;
            }
        }
    </script> -->

    <!-- 6 函数本身的作用域 -->
    <!-- <script>
        // var x = function () {
        //     console.log(a)
        // }
        // function y(f) {
        //     var a = 2
        //     f()
        // }
        // y(x)
        // ReferenceError: a is not defined
        // 上面代码将函数x作为参数，传入函数y。但是，函数x是在函数y体外声明的，作用域绑定外层，因此找不到函数y的内部变量a，导致报错。

        function foo() {
            var x = 1;
            function bar() {
                console.log(x);
            }
                return bar;
        }
        var x = 2;
        var f = foo();
        f() // 1
        // 上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了下文要讲解的“闭包”现象。
    </script> -->

    <!-- 7 参数的省略 -->
    <!-- <script>
        // 函数参数不是必需的，JavaScript 允许省略参数。
        function fn(a, b) {
            return console.log(a)
        }
        fn(1, 2, 3) //1
        fn(1, 2) //1
        fn(1) //1
        fn() //undefined

        // 但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。
        function fn2(a, b) {
            console.log(a)
            console.log(b)
        }
        fn(undefined, 2) //undefined
    </script> -->

    <!-- 8 传递的方式 -->
    <!-- <script>
        // 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。
        var p = 2
        function f(p) {
            p = 3
        }
        f(p)
        console.log(p) //2

        // 但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。
        var obj = {
            p: 1
        }
        function f1(obj) {
            obj.p = 2
        }
        f1(obj)
        console.log(obj.p) //2

        // 注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。
        // 这是因为，形式参数（o）的值实际是参数obj的地址，重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响。
        var obj2 = [1, 2, 3]
        function fn2(o) {
            o = [4, 5, 6]
        }
        fn2(obj2)
        console.log(obj2) //(3) [1, 2, 3]
    </script> -->

    <!-- 9 同名参数-->
    <!-- <script>
        // 如果有同名的参数，则取最后出现的那个值。
        function f1(a, a) {
            console.log(a);
        }
        f1(1, 2) // 2

        // 调用函数f()的时候，没有提供第二个参数，a的取值就变成了undefined。
        function f2(a, a) {
            console.log(a);
        }
        f2(1) // undefined

        // 如果要获得第一个a的值，可以使用arguments对象。
        function f3(a, a) {
            console.log(arguments[0]);
        }
        f3(1) // 1
    </script> -->

    <!-- 10 -->
    <script>
        // JavaScript 允许函数有不定数目的参数
        // arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。
        var f1 = function (one) {
            console.log(arguments[0])
            console.log(arguments[1])
            console.log(arguments[2])
        }

        f1(1, 2, 3)
        // 1
        // 2
        // 3

        // 正常模式下，arguments对象可以在运行时修改。
        var f2 = function(a, b) {
            arguments[0] = 3
            arguments[1] = 2
            return a + b
        }
        console.log(f2(1, 1)) // 5
         
        // 严格模式下，arguments对象与函数参数不具有联动关系。也就是说，修改arguments对象不会影响到实际的函数参数。
        var f3 = function(a, b) {
            'use strict'; // 开启严格模式
            arguments[0] = 3
            arguments[1] = 2
            return a + b
        }
        console.log(f3(1, 1)) // 2

        // 通过arguments对象的length属性，可以判断函数调用时到底带几个参数。
        function f4() {
            return arguments.length
        }
        console.log(f4(1, 2, 3)) //3
        console.log(f4(1)) //1
        console.log(f4()) //0
        
        // 需要注意的是，虽然arguments很像数组，但它是一个对象。
        // 如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。
        function f5() {
            var args = Array.prototype.slice.call(arguments)
            // 或者
            var args = []
            for (var i = 0; i < arguments.length; i++) {
                args.push(arguments[i])
            }
        }

        // arguments对象带有一个callee属性，返回它所对应的原函数。
        var f6 = function () {
            console.log(arguments.callee === f6)
        }
        f6() // true

    </script>
</body>
</html>